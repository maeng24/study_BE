##알아두어야 할 자바 스크립트

### 호출 스택
 - anonymous는 가상의 전역 컨텍스트(항상 있다고 생각하는 게 좋음)
 - 함수 호출 순서대로 쌓이고, 역순으로 실행됨
 - 함수 실행이 완료되면 스택에서 빠짐
 - LIFO 구조라서 스택이라고 불림
 - 호출스택만으로는 설명이 안되는 순서가 있음 (setTimeOut 등 사용)
   - 호출스택 + 이벤트 루프로 설명 가능

### 이벤트루프
 - 대략적인 진행 순서
   - 백그라운드에 비동기로 함수를 보냈을 경우, 호출 스택의 동작과 관계 없이 동작하기 때문에 동시에 실행 될 수 있다.
   - 백그라운드에서 조건에 따라 호출스택에 함수를 보내고 백그라운드를 비운다.
   - 호출스택이 비었으면(anonymous도 모두 비어야 함) 태스크 큐에 있는 함수를 가지고 와서 호출해준다.
   - 호출스택, 백그라운드, 태스크 큐의 실행이 모두 완료되었을 때 자바스크립트의 실행이 완료된다.
 - 노드에서 백그라운드로 갈 수 있는 함수는 제한되어 있다.
 - Promise .then/catch, process.nextTick 처럼 우선순위가 높은 함수가 있을 경우 먼저 호출스택으로 보내줌
 
 - 백그라운드는 c++, 운영체제 등 다른 언어로 되어있는 부분. 
 - 자바스크립트 엔진이 알아서 해주는 부분.
 - 따라서 자바스크립트는 싱글 스레드.
 
### const, let
 - ES2015 이전에는 var로 변수 선언.
   - 이후로는 const 와 let이 대체
   - 가장 큰 차이점 : 블록 스코프(var는 함수 스코프)
 - 기존 : 함수 스코프 (function(){} 이 스코프의 기준점)
   - 다른 언어와 달리 if for while의 {}는 영향을 끼치지 못함.
   - const let은 함수 및 블록 ({}) 에도 별도의 스코프를 가진다.
 - const 
   - 상수
   - 값을 바꾸려 하면 에러 발생
   - 객체로 선언시 객체 내부는 변경 가능
 - let
   - 변수
   - 언제든 값을 바꿀 수 있음

### 템플릿 문자열, 객체 리터럴
 - 문자열을 합칠 때 템플릿 문자열을 사용 (백틱 문자열, ₩) 하면, 문자열 사이에 ${}를 넣어 문자열 사이 변수 호출 가능
 - 객체 리터럴 
   - 객체의 메서드에 :function 을 붙이지 않아도 됨
   - {sayNode:sayNode}와 같은 것들을 {sayNode}로 축약 가능
   - [변수+값] 등으로 동적 속성명을 객체 속성명으로 사용 가능
 
### 화살표 함수
 - 함수 선언시 중괄호랑 리턴을 생략 가능.
 - 매개변수가 하나일 경우 매개변수에도 괄호 생략 가능.
 - 객체리턴({})시에 소괄호 필수 (함수의 본문(body)인지 객체인지 엔진이 알 수 없음)
 - 화살표 함수는 자신을 포함하는 함수의 this를 물려받음.
 
### 구조분해 (비구조화) 할당
 - example = {a:123,b:{c:135,d:246}}
 - const {a,b:{d}} =example;
 - arr=[1,2,3,4,5]
 - const [x,y,,,z] = arr; => 2,3번 째는 변수대입을 하지 않는다는 뜻. 자리를 잘 맞추어 주어야 함
 - this가 있는 경우, 구조분해 X

### 클래스
 - 프로토타입 문법을 깔끔하게 작성할 수 있는 Class 문법 도임
 - Constructor(생성자), Extends(상속) 등을 깔끔하게 처리할 수 있음
 - 코드가 그룹화되어 가독성이 향상 됨

### Promise
 - 콜벡 헬이라고 불리는 지저분한 자바스크립트 코드의 해결책
    - 프로미스 : 내용이 실행 되었지만, 결과를 아직 반환하지 않은 객체
    - then을 붙이면 결과를 반환함.
    - 실행이 완료되지 않았으면 완료된 후에 then 내부 함수가 실행됨
    - finally 부분은 무조건 실행 됨.
 - 실행 이후 필요할 때 값을 꺼내 쓸 수 있음
 - 프로미스 사용
   - Promise.resolve(성공리턴값): 바로 resolve하는 프로미스
   - Promise.reject(실패리턴값): 바로 reject하는 프로미스
   - Promise.All(배열):여러개의 프로미스를 동시에 실행. 하나라도 실패하면 catch로 감
   - Promise.allSettled(): 실패한 것만 추려낼 수 있음.
 - 이전 챕터의 프로미스 패턴 코드
   - Async/await으로 축약 가능

### Async, await
 - 변수 = await 프로미스; 인 경우 프로미스가 resolve 된 값이 변수에 저장
 - 프로미스의 문법을 간단하게 만든 것 -> 프로미스의 성질을 그대로 가진다.
 - catch가 없기 때문에, 실패를 가정하여 reject를 try catch 문으로 감싸서 처리 해줘야함
 - async는 항상 프로미스 객체를 반환
 - for await (변수 of 프로미스 배열)
   - resolve된 프로미스가 변수에 담겨 나옴
   - await을 사용하기 때문에 async 함수 안에서 해야 함

### 프론트엔드 자바스크립트
 - 서버로 요청을 보내는 코드
   - 라이브러리 없이는 브라우저가 지원하는 XMLHttpRequest 객체 이용
   - AJAX요청 시 Axios 라이브러리를 사용하는 것이 편함
 - Get 요청 보내기
   - axios.get 함수의 인수로 요청 보낼 주소를 넣으면 됨.
   - 프로미스 기반 코드라 async/await 사용 가능
 - Post 요청을 하는 코드 (데이터를 담아 서버로 보내는 경우)
   - 전체적인 구조는 비슷하나 두 번째 인수로 데이터를 넣어 보냄
 - HTML form 태그에 담긴 데이터를 AJAX 요청으로 보내고 싶은 경우
   - FormData 객체 이용
   - Axios의 data 자리에 formData를 넣으면 됨
 - 가끔 주소창에 한글을 입력하면 서버가 처리하지 못하는 경우가 발생
   - encodeURIComponent로 한글 감싸줘서 처리
   - decodeURIComponent로 서버에서 한글 해석
 - HTML 태그에 데이터를 저장하는 방법
   - 서버의 데이터를 프런트엔드로 내려줄 때 사용
   - 태그 속성으로 data - 속성명
   - 자바스크립트에서 태그.dataset.속성명으로 접근 가능
   - 반대로 자바스크립트 dataset에 값을 넣으면 data-속성이 생긴다.
